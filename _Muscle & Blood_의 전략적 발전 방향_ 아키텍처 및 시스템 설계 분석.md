"Muscle & Blood"의 전략적 발전 방향: 아키텍처 및 시스템 설계 분석
Executive Summary
본 보고서는 턴제 자동 전투 RPG "Muscle & Blood"의 프로젝트 개요를 기반으로, 게임의 핵심 잠재력을 극대화하고 장기적인 성공을 담보하기 위한 심층적인 기술 및 전략적 발전 방향을 제시한다. "Muscle & Blood"는 영지 경영, 용병 수집, 그리고 [용맹] 및 [무게] 시스템과 같은 독창적인 메커니즘을 결합하여 깊이 있는 전략적 경험을 제공할 잠재력을 지니고 있다.

본 분석은 프로젝트의 세 가지 핵심 개선 과제인 AI 고도화, 데이터 지향 설계 심화, 그리고 상태 저장 및 영속성을 중심으로 진행되며, 여기에 더해 장기적인 플레이어 몰입을 위한 메타 게임 설계를 추가적으로 제안한다.

주요 권장 사항은 다음과 같다.

AI 아키텍처: 현재의 조건부 로직을 넘어, 행동 트리(Behavior Tree)와 유틸리티 시스템(Utility System)을 결합한 하이브리드 모델을 채택할 것을 권장한다. 이 접근법은 디자이너의 통제력을 유지하면서도, [용맹]과 [무게] 시스템의 복잡한 딜레마를 AI가 상황에 맞게 유연하고 지능적으로 판단하게 하여 전술적 깊이를 더할 것이다.

데이터 지향 설계: 현재의 모듈식 아키텍처에서 Unity의 DOTS(Data-Oriented Technology Stack)를 활용한 하이브리드 ECS(Entity-Component-System)로의 점진적 전환을 제안한다. 이는 전투 시뮬레이션과 같이 성능이 중요한 핵심 시스템부터 ECS로 전환하여 캐시 효율성과 병렬 처리를 극대화하고, UI와 같은 다른 시스템은 기존의 GameObject 방식을 유지하여 개발 효율성과 안정성을 모두 확보하는 실용적인 전략이다.

데이터 저장 및 보안: RPG의 필수 요소인 저장/불러오기 기능은 MessagePack-CSharp 라이브러리를 이용한 고성능 바이너리 직렬화를 기반으로 구현할 것을 제안한다. 특히, 가챠 기반의 용병 수집 시스템은 데이터 변조에 대한 강력한 동기를 부여하므로, 단순 암호화를 넘어 체크섬을 통한 데이터 무결성 검증, AES-256 암호화, 그리고 Android Keystore 및 iOS Secure Enclave를 활용한 하드웨어 기반 키 저장에 이르는 다계층 보안 모델을 적용하여 게임의 경제 시스템과 공정성을 보호해야 한다.

메타 게임 심화: "영지 경영" 시스템을 Darkest Dungeon의 '가주'나 XCOM의 '어벤저'와 같이, 전술적 전투와 유기적으로 연결된 핵심 장기 성장 루프로 발전시킬 것을 제안한다. 자원 관리, 건물 업그레이드, 그리고 가챠 시스템과의 연계를 통해 플레이어에게 지속적인 목표를 제공하고, 이는 게임의 리플레이 가치와 장기적인 몰입도를 크게 향상시킬 것이다.

본 보고서는 이러한 권장 사항에 대한 상세한 기술적 분석, 구현 지침, 그리고 예상되는 장단점을 포괄적으로 제공하여 "Muscle & Blood"가 성공적인 게임으로 완성되는 데 기여하고자 한다.

Part I: Architecting Intelligent Opposition - The Evolution of AI in "Muscle & Blood"
"Muscle & Blood"의 전투 시스템은 [용맹]과 [무게]라는 독창적인 메커니즘을 통해 깊이 있는 전략적 선택지를 제공한다. 이러한 시스템의 잠재력을 온전히 발휘하기 위해서는, 플레이어의 전략에 지능적으로 대응하고 게임의 핵심 딜레마를 이해하는 AI의 구현이 필수적이다. 본 파트에서는 현재의 조건부 AI 로직을 넘어, 보다 정교하고 전술적인 AI를 구축하기 위한 아키텍처 선정과 구체적인 설계 방안을 제시한다.

Section 1.1: Selecting the Right AI Paradigm - Control vs. Emergence
게임 AI를 설계하는 것은 단순히 '더 똑똑한' AI를 만드는 것을 넘어, 게임플레이 경험을 어떻게 형성할 것인가에 대한 근본적인 철학의 문제이다. 프로젝트 개요에서 언급된 행동 트리(Behavior Tree, BT)로의 전환은 올바른 방향이지만, 그 대안으로 자주 거론되는 GOAP(Goal-Oriented Action Planning)과 같은 계획 기반 시스템과의 비교를 통해 왜 BT가 "Muscle & Blood"에 더 적합한 선택인지 명확히 할 필요가 있다.

Behavior Trees (BTs) as the Pragmatic Foundation
행동 트리는 현대 게임 AI 개발에서 사실상의 산업 표준으로 자리 잡았다.

Halo 시리즈나 Crysis 2와 같은 AAA급 타이틀에서 그 효율성이 입증되었으며, 이는 BT가 제공하는 명확한 장점들 때문이다. BT의 가장 큰 강점은 

디자이너의 통제력에 있다. BT는 본질적으로 복잡한 'if-then-else' 문의 시각적 표현으로, 디자이너가 AI의 행동 흐름을 직관적으로 이해하고, 시각화하며, 디버깅하기 용이하다.

"Muscle & Blood"와 같이 전술적 깊이와 균형이 중요한 게임에서, AI는 플레이어에게 '흥미로운 도전'을 제공하는 역할을 해야 한다. 이는 AI가 때로는 최적이 아닌, 예측 가능하고 학습 가능한 패턴을 보여주어야 함을 의미한다. BT는 이러한 '재미를 위한 행동'을 디자이너가 직접 설계하고 제어할 수 있게 해준다. 예를 들어, 특정 상황에서 AI가 무모한 공격을 감행하거나, 명백한 약점을 노출하는 등의 행동은 게임을 더 흥미롭게 만들 수 있으며, 이는 BT를 통해 명시적으로 구현될 수 있다.

Evaluating GOAP and HTNs
반면, GOAP와 같은 계획 기반 시스템은 AI에게 목표(Goal)와 가능한 행동(Action) 집합을 제공한 뒤, "스스로 규칙을 찾도록" 하는 방식이다. 이는 개발자가 모든 상황에 대한 규칙을 하드코딩할 필요 없이, AI가 동적으로 행동 계획을 수립하게 하여 매우 복잡하고 예측 불가능한 상황에 대응할 수 있게 한다.

그러나 이러한 창발성(Emergence)은 상당한 대가를 요구한다. 첫째, 구현 및 디버깅의 복잡성이 매우 높다. AI가 예상치 못한 행동을 할 때, 그 원인을 추적하는 것은 BT의 노드를 따라가는 것보다 훨씬 어렵다. 둘째, 

성능 부하가 크다. 가능한 모든 행동 순서를 탐색하는 과정은 BT의 단순한 조건 검사에 비해 훨씬 많은 연산을 필요로 한다. 마지막으로, 그리고 가장 치명적으로, 

디자이너의 통제력을 상실하게 된다. AI가 찾아낸 최적의 해결책이 게임의 재미를 해치거나(too effective or not fun), 플레이어에게 불쾌한 경험을 줄 수 있다.

예를 들어, [용맹] 시스템의 허점을 파고들어 극도로 효율적이지만 비겁하게 느껴지는 플레이를 GOAP 기반 AI가 스스로 발견할 수 있다. 이는 게임의 전술적 의도를 훼손하는 결과로 이어진다. 계층적 작업 네트워크(Hierarchical Task Networks, HTN)는 GOAP보다 디자이너의 통제력을 더 많이 제공하는 대안이지만, 여전히 BT에 비해서는 복잡성이 높다.

Recommendation and Rationale
따라서 "Muscle & Blood"의 AI 시스템은 행동 트리(BT)를 핵심 아키텍처로 채택하는 것이 가장 합리적이다. 이는 다음과 같은 논리적 귀결에 따른다.

게임의 핵심 메커니즘은 플레이어의 전략적 숙달을 위해 설계되었다. [용맹]과 [무게] 시스템은 플레이어가 깊이 고민하고 숙달해야 할 딜레마를 제공한다.

AI는 이러한 메커니즘을 플레이어에게 '가르치고' 도전하는 역할을 해야 한다. AI의 행동은 시스템의 깊이를 보여주는 예시가 되어야 하며, 플레이어가 그 원리를 이해하고 파훼하는 재미를 느껴야 한다.

GOAP의 창발성은 이러한 역할을 수행하기에 부적합하다. GOAP AI는 시스템의 허점을 '악용'할 수 있지만, 시스템의 재미를 '연출'하도록 설계하기는 어렵다. 이는 플레이어에게 좌절감을 주거나 게임의 의도를 왜곡시킬 수 있다.

BT는 디자이너가 AI의 행동을 직접 제어하여 의도된 전술적 경험을 제공할 수 있게 한다. 예를 들어, 디자이너는 [용맹] 수치가 높은 적은 공격적으로 행동하고, 낮은 적은 방어적으로 행동하도록 명시적인 BT를 구성할 수 있다. 이를 통해 플레이어는 AI의 행동을 관찰하며 [용맹] 시스템의 중요성을 자연스럽게 학습하게 된다.

결론적으로, "Muscle & Blood"의 게임플레이 경험을 최우선으로 고려할 때, AI의 행동을 명확하게 제어하고 설계할 수 있는 행동 트리(BT)가 가장 적합한 패러다임이다.

Section 1.2: From Binary Choices to Nuanced Tactics - Integrating Utility Theory
행동 트리(BT)를 기본 아키텍처로 채택하는 것은 올바른 첫걸음이지만, 표준적인 BT 구현은 근본적인 한계를 가지고 있다. 바로 정적인 우선순위(static priority) 문제이다. BT에서 행동의 우선순위는 트리의 구조 자체에 고정되어 있어, "이것 아니면 저것"과 같은 이진(binary) 결정에 강하지만, 여러 유효한 선택지 사이에서 미묘한 가치를 비교하는 "회색 영역(gray area)"의 의사결정에는 취약하다.

"Muscle & Blood"의 [용맹]과 [무게] 시스템은 바로 이 회색 영역의 딜레마를 핵심으로 한다. 높은 [용맹] 수치는 공격력 증가라는 이점과 동시에 보호막이라는 방어적 가치를 지닌다. 무거운 장비는 강력한 성능을 제공하지만 행동 순서에 페널티를 준다. 이러한 복합적인 상황에서 AI가 단순히 "체력이 50% 이하이면 방어"와 같은 경직된 규칙을 따르는 것은 게임의 전략적 깊이를 제대로 표현하지 못한다. 이 문제를 해결하기 위한 가장 효과적인 방법은 BT에 **유틸리티 이론(Utility Theory)**을 접목하는 것이다.

Architectural Proposal: The Hybrid BT/Utility System
유틸리티 시스템(Utility System, US)은 각 행동의 '유용성'을 수치화하여 가장 가치 있는 행동을 선택하는 AI 모델이다. 이를 BT와 결합한 하이브리드 아키텍처는 BT의 구조적 명확성과 US의 동적 유연성을 모두 취할 수 있는 강력한 해결책이다.

구체적인 아키텍처는 BT에 **'유틸리티 셀렉터(Utility Selector)'**라는 새로운 유형의 노드를 도입하는 것이다. 일반적인 셀렉터 노드가 자식 노드들을 순서대로 실행하며 성공하는 첫 번째 노드를 선택하는 반면, 유틸리티 셀렉터는 다음과 같이 작동한다.

점수 계산: 연결된 모든 자식 노드(행동)에게 "지금 이 행동을 수행하는 것이 얼마나 유용한가?"를 묻고, 각 행동은 현재 게임 상황을 기반으로 0과 1 사이의 유틸리티 점수(utility score)를 계산하여 반환한다.

최적 행동 선택: 유틸리티 셀렉터는 모든 자식 노드로부터 반환된 점수들을 비교하여 가장 높은 점수를 받은 행동을 최종적으로 선택하여 실행한다.

이 구조를 통해 AI는 더 이상 사전에 정의된 우선순위에 얽매이지 않고, 매 순간 가장 '합리적인' 선택을 동적으로 내릴 수 있게 된다. 이는 BT의 구조를 유지하면서도 결정의 질을 한 차원 높이는 방식이다.

Practical Implementation - Designing Utility Functions
하이브리드 시스템의 핵심은 각 행동의 유틸리티 점수를 어떻게 계산할 것인가, 즉 **유틸리티 함수(Utility Function)**를 설계하는 데 있다. 이 함수는 다양한 게임 상태 변수를 입력받아 정규화된 점수를 출력하는 곡선(response curve)의 형태를 띤다. "Muscle & Blood"의 핵심 시스템을 위한 유틸리티 함수 예시는 다음과 같다.

[용맹] 시스템을 고려한 공격 행동 유틸리티:

입력 변수: 자신의 [용맹] 수치(V), 대상의 남은 체력 비율(THP), 대상의 위협도(Threat).

유틸리티 함수 예시: U 
attack
​
 =(1−THP)×w 
hp
​
 +Threat×w 
threat
​
 +(V/V 
max
​
 )×w 
valor
​
 

해석: 이 함수는 대상의 체력이 낮을수록, 위협도가 높을수록 높은 공격 유틸리티를 부여한다. 또한, 자신의 [용맹] 수치가 높을수록(공격력 증폭 효과) 공격의 가치가 추가로 높아진다. 각 w는 가중치(weight)로, AI 성향(공격적, 방어적)에 따라 조절할 수 있다.

[무게] 시스템을 고려한 행동 선택 유틸리티:

입력 변수: 자신의 총 무게, 예상 턴 순서(TurnOrder), 스킬의 위력(Power).

유틸리티 함수 예시: U 
action
​
 =Power×w 
power
​
 −(W/W 
max
​
 )×w 
weight
​
 −(TurnOrder/TotalUnits)×w 
turn
​
 

해석: 스킬의 위력이 높을수록 유틸리티가 증가하지만, 무게와 턴 순서에 따른 페널티가 유틸리티를 감소시킨다. 이를 통해 AI는 강력하지만 느린 공격과 약하지만 빠른 공격 사이에서 합리적인 저울질을 할 수 있다.

방어적 행동(보호막 유지) 유틸리티:

입력 변수: 자신의 [용맹] 수치(V), 자신의 체력 비율(HP).

유틸리티 함수 예시: U 
defend
​
 =(1−(V/V 
max
​
 ))×w 
valor_preserve
​
 +(1−HP)×w 
hp_preserve
​
 

해석: [용맹] 수치가 낮을수록, 그리고 자신의 체력이 낮을수록 방어적 행동의 가치가 급격히 증가한다.

이러한 접근법은 [용맹]과 [무게] 시스템이 단순한 스탯이 아니라, AI가 관리하고 활용해야 하는 동적인 자원 경제로 작동하게 만든다. 단순한 BT는 이 경제 시스템을 효과적으로 운영할 수 없지만, 유틸리티 시스템은 각 행동의 '기회비용'과 '기대효용'을 계산하여 최적의 경제 활동을 수행할 수 있게 한다. 이는 플레이어에게 AI가 단순히 강한 것이 아니라, 게임의 규칙을 이해하고 '플레이'하고 있다는 인상을 주어 훨씬 더 깊은 몰입감을 선사할 것이다.

Proposed Table 1: Sample Utility Function Matrix for a "Tank" Class
다음 표는 "Muscle & Blood"의 '탱커' 클래스 AI가 가질 수 있는 유틸리티 함수 설계를 구체화한 예시이다. 이는 추상적인 개념을 실제 개발에 적용 가능한 설계 문서로 변환하는 데 도움을 줄 것이다.

주: 위 표의 수치는 예시이며, 실제 게임 밸런스에 맞춰 정교한 튜닝이 필요하다. 각 값은 0에서 1 사이로 정규화된 입력값을 가정한다.

Part II: Building for Performance and Scalability - A Pragmatic Transition to Data-Oriented Design
"Muscle & Blood"의 기술 아키텍처는 이미 데이터 지향 설계(Data-Oriented Design, DOD) 원칙을 인지하고 있으며, 이는 장기적인 성능과 확장성을 위한 훌륭한 기반이다. 프로젝트가 성숙함에 따라, 이 원칙을 더욱 심화시켜 Unity의 DOTS(Data-Oriented Technology Stack)와 같은 현대적인 패러다임의 이점을 최대한 활용하는 것이 다음 단계의 핵심 과제이다. 본 파트에서는 현재의 모듈식 구조에서 완전한 데이터 지향 아키텍처로 나아가는 실용적이고 단계적인 전환 전략을 제안한다.

Section 2.1: The Journey from OOP to ECS - A Strategic Migration Plan
객체 지향 프로그래밍(OOP)에서 데이터 지향 설계(DOD)로의 전환, 그리고 그 최종 형태 중 하나인 엔티티-컴포넌트-시스템(Entity-Component-System, ECS) 아키텍처로의 이전은 단순히 코딩 스타일을 바꾸는 것이 아니라, 데이터와 로직을 바라보는 관점 자체를 바꾸는 패러다임의 전환이다. ECS의 핵심 이점은 성능에 있다. 데이터를 컴포넌트 단위로 분리하고, 이를 메모리에 연속적으로 배치함으로써 CPU 캐시 효율을 극대화(데이터 지역성)하고, 시스템(로직)이 이 데이터 묶음을 병렬로 처리하기 용이하게 만들어준다.

The Pitfalls of a "Pure ECS" Approach
그러나 모든 것을 ECS로 전환하려는 시도는 종종 함정에 빠지기 쉽다. '순수 ECS' 접근법은 다음과 같은 명백한 단점을 가진다.

가파른 학습 곡선: ECS는 전통적인 OOP와 사고방식이 다르기 때문에 개발자가 새로운 개념에 익숙해지는 데 시간이 걸린다.

디버깅의 어려움: 데이터와 로직이 분리되어 있어 특정 엔티티의 문제를 추적하기가 OOP보다 복잡할 수 있다. 특히 시각적 디버거는 정수 ID와 간접 참조로 구성된 ECS 구조를 직관적으로 보여주기 어렵다.

엔진 기능과의 비호환성: Unity 에디터의 많은 기능, 특히 UI 시스템(UGUI)이나 애니메이션 시스템(Mecanim)은 근본적으로 GameObject 기반으로 설계되어 ECS와 자연스럽게 통합되지 않는다.

게임의 모든 부분을 ECS로 억지로 끼워 맞추려는 시도는 개발 생산성을 심각하게 저해하고, 불필요한 복잡성만 가중시키는 흔한 안티패턴이다.

Recommendation: The Hybrid ECS Architecture
이러한 문제에 대한 가장 실용적이고 널리 권장되는 해결책은 **하이브리드 ECS 아키텍처(Hybrid ECS Architecture)**를 채택하는 것이다. 이 모델은 게임의 각 부분을 분석하여 ECS의 이점을 최대로 누릴 수 있는 영역과, 기존의 GameObject/MonoBehaviour 방식이 더 효율적인 영역을 구분하여 두 패러다임을 함께 사용하는 접근법이다.

ECS 전환 대상 (Pure ECS):

전투 시뮬레이션: 수많은 유닛의 데미지 계산, 상태 효과 적용, 스킬 처리 등은 대규모 데이터에 대한 반복적인 연산이므로 ECS에 가장 적합하다. 병렬 처리를 통해 전투 로직의 성능을 극적으로 향상시킬 수 있다.

[무게] 시스템 기반 턴 순서 계산: 모든 유닛의 무게 값을 읽어 턴 순서를 정렬하는 작업은 데이터 병렬 처리의 전형적인 예시다.

AI 에이전트 데이터 관리: 수십 개의 AI 유닛이 각자의 상태(체력, 위치, 타겟 등)를 가지는 경우, 이 데이터들을 컴포넌트로 관리하면 AI 시스템이 효율적으로 접근하고 처리할 수 있다.

GameObject 유지 대상 (Classic OOP/Component-Based):

UI 시스템: Unity의 UGUI는 이벤트 기반이며 GameObject 계층 구조에 깊이 의존하므로, 이를 ECS로 변환하려는 시도는 비효율적이다.

고수준 게임 상태 관리: MainMenu -> EstateManagement -> Battle과 같은 게임의 전체적인 흐름을 제어하는 상태 머신은 소수의 객체만 관리하므로 ECS의 이점이 거의 없다.

일회성 이벤트 및 씬 관리: 특정 컷신을 재생하거나 씬을 로드하는 등의 로직은 기존 MonoBehaviour 스크립트로 처리하는 것이 훨씬 간단하고 직관적이다.

이러한 하이브리드 접근법은 성능이 가장 중요한 곳에 ECS를 집중적으로 투자하고, 나머지 부분에서는 Unity의 검증된 워크플로우를 활용하여 개발 생산성을 유지하는, 위험 부담이 적고 효과적인 전략이다.

Section 2.2: Technical Implementation with Unity's Data-Oriented Technology Stack (DOTS)
Unity는 하이브리드 ECS 아키텍처를 구현하기 위한 강력한 도구 모음인 **DOTS(Data-Oriented Technology Stack)**를 제공한다. DOTS는 세 가지 핵심 기술로 구성된다 :

Entity Component System (ECS): 데이터와 로직을 분리하는 핵심 아키텍처.

C# Job System: 멀티코어 CPU를 활용하여 코드를 안전하게 병렬 실행하는 시스템.

Burst Compiler: C# 코드를 고도로 최적화된 네이티브 코드로 변환하는 컴파일러.

이 세 가지 기술의 조합은 "Muscle & Blood"의 아키텍처를 한 단계 발전시킬 강력한 시너지를 창출한다.

Refactoring Example - The System
[무게] 시스템이 턴 순서에 미치는 영향을 DOTS로 리팩토링하는 과정은 다음과 같다.

데이터 정의 (Components):

WeightComponent: 유닛의 총 무게 값을 저장하는 IComponentData 구조체.

TurnOrderComponent: 계산된 턴 순서 값을 저장하는 IComponentData 구조체.

로직 정의 (System & Job):

WeightToTurnOrderSystem: WeightComponent를 가진 모든 엔티티를 찾아 TurnOrderComponent 값을 계산하는 ISystem.

WeightCalculationJob: 실제 계산을 수행하는 IJobEntity 구조체.

시스템 실행 (Scheduling):

OnUpdate 메서드 내에서 WeightCalculationJob을 스케줄링한다. C# Job System은 이 작업을 워커 스레드에 분배하여 메인 스레드를 차단하지 않고 병렬로 실행한다.

From Web Workers to the C# Job System
현재 아키텍처에서 BattleCalculationManager가 Web Worker를 사용하여 메인 스레드의 부하를 줄이는 방식은 DOTS의 철학과 정확히 일치한다. 이는 이미 데이터와 로직을 분리하고 비동기 처리를 도입하려는 올바른 방향성을 보여준다. 그러나 Web Worker는 브라우저 환경에 맞춰진 범용 기술으로, 게임 엔진 내부의 최적화에는 한계가 있다. 메시지를 주고받는 과정에서 발생하는 직렬화/역직렬화 오버헤드가 존재하며, 데이터 접근이 간접적이다.

C# Job System으로의 마이그레이션은 이러한 한계를 극복하는 자연스러운 진화 과정이다. Job System은 Unity 엔진과 긴밀하게 통합되어 있어, NativeArray와 같은 특수 컨테이너를 통해 메모리를 직접 공유하므로 데이터 복사나 직렬화 비용이 거의 없다. 여기에 Burst Compiler가 더해지면, C#으로 작성된 코드가 C++ 수준, 혹은 그 이상의 고도로 최적화된 네이티브 코드로 변환되어 실행된다. 따라서 현재의 Web Worker 기반 로직을 Bursted C# Job으로 전환하는 것은 성능을 극대화하는 가장 확실한 방법이다.

Debugging and Profiling in a DOTS Environment
하이브리드 ECS 환경의 디버깅은 복잡하지만, Unity는 이를 지원하기 위한 전문적인 도구들을 제공한다. 성공적인 전환을 위해서는 이 도구들에 대한 숙지가 필수적이다.

Entity Debugger: 월드에 존재하는 모든 엔티티, 컴포넌트, 아키타입의 상태를 실시간으로 확인하고 수정할 수 있는 가장 기본적인 도구이다.

Profiler Modules: Unity 프로파일러에는 DOTS를 위한 전용 모듈이 포함되어 있다. 'Entities Structural Changes' 모듈은 엔티티 생성/삭제나 컴포넌트 추가/제거 시 발생하는 성능 비용을 추적하고, 'Entities Memory' 모듈은 청크와 아키타입의 메모리 사용량을 시각화하여 보여준다.

Burst Inspector: ``된 잡이 실제로 어떻게 네이티브 코드로 변환되었는지, 특히 SIMD(Single Instruction, Multiple Data) 벡터화가 제대로 이루어졌는지 등을 상세히 분석할 수 있게 해준다.

이 도구들을 활용하여 "어디서 병목이 발생하는가?"를 조기에 파악하고 최적화하는 반복적인 프로세스를 개발 초기에 정립하는 것이 중요하다.

Proposed Table 2: Componentization Priority Matrix
다음 매트릭스는 "Muscle & Blood"의 시스템들을 ECS로 전환하기 위한 단계적 로드맵을 제시한다. 이는 개발 우선순위를 정하고, 전환 과정의 리스크를 관리하는 데 도움을 줄 것이다.

Part III: Ensuring Permanence and Integrity - A Robust System for Save Data
RPG 장르에서 게임 진행 상황을 저장하고 불러오는 기능은 플레이어 경험의 핵심이다. 특히 "Muscle & Blood"와 같이 장기적인 영지 경영과 용병 육성을 특징으로 하는 게임에서, 데이터의 영속성과 무결성은 게임의 가치를 지탱하는 기둥과 같다. 본 파트에서는 "상태 저장 및 영속성" 과제를 해결하기 위해, 빠르고 효율적이면서도 외부의 악의적인 조작으로부터 데이터를 안전하게 보호할 수 있는 견고한 저장 시스템 아키텍처를 제안한다.

Section 3.1: Serialization Architecture - Speed, Size, and Versioning
게임의 상태(플레이어 정보, 용병 데이터, 영지 상태 등)를 파일로 저장하기 위해서는 먼저 이 메모리 상의 객체들을 연속적인 바이트 스트림으로 변환하는 직렬화(Serialization) 과정이 필요하다. 이때 어떤 직렬화 포맷과 라이브러리를 선택하느냐가 저장/불러오기 속도, 파일 크기, 그리고 향후 유지보수성에 결정적인 영향을 미친다.

Binary vs. Text Formats
직렬화 포맷은 크게 텍스트 기반(JSON, XML 등)과 바이너리 기반으로 나뉜다. 디버깅이나 데이터 확인의 용이성 때문에 텍스트 포맷을 고려할 수 있으나, 게임 저장 데이터와 같이 성능이 중요한 경우에는 바이너리 포맷이 명백한 우위를 점한다.

성능 및 크기: 바이너리 포맷은 데이터를 메모리 표현에 가깝게 저장하므로 파싱 속도가 월등히 빠르고 결과 파일의 크기가 훨씬 작다. 이는 특히 모바일 환경에서 로딩 시간을 단축하고 저장 공간을 절약하는 데 매우 중요하다.

가독성: 바이너리 포맷의 유일한 단점은 사람이 직접 읽기 어렵다는 것이지만, 이는 암호화를 적용하면 어차피 해결되는 문제이므로 실질적인 단점으로 보기 어렵다.

Library Selection: MessagePack vs. Protobuf
C# 환경의 Unity에서 사용할 수 있는 고성능 바이너리 직렬화 라이브러리로는 MessagePack과 Protobuf가 대표적이다.

MessagePack: "JSON과 유사하지만, 더 빠르고 작다"는 모토처럼, 높은 성능과 압축률을 자랑한다. 특히 커뮤니티에서 널리 사용되는 

MessagePack-CSharp 라이브러리는 Unity의 IL2CPP 및 AOT(Ahead-Of-Time) 컴파일 환경을 완벽하게 지원하며, 성능 벤치마크에서 최상위권을 기록하고 있다.

[Key] 어트리뷰트를 통해 직렬화할 필드를 명시하는 방식과, 어트리뷰트 없이 모든 public 멤버를 직렬화하는 ContractlessStandardResolver 방식을 모두 지원하여 유연성이 높다.

Protobuf (Protocol Buffers): 구글에서 개발한 Protobuf 역시 최고의 성능과 압축률을 제공하며, .proto라는 스키마 정의 파일을 통해 여러 플랫폼 간의 데이터 호환성을 보장하는 데 강점이 있다. 하지만 이 스키마 우선 방식은 게임 개발 과정에서 데이터 구조가 자주 변경될 때 다소 번거로울 수 있다.

권장 사항: MessagePack-CSharp 라이브러리를 채택할 것을 권장한다. 최상급 성능을 제공하면서도, Protobuf에 비해 유연한 어트리뷰트 기반 모델을 제공하여 반복적인 수정이 잦은 게임 개발 환경에 더 적합하다.

Handling Data Versioning
게임이 업데이트되면서 저장 데이터의 구조가 변경되는 것은 필연적이다. 이를 처리하지 못하면 이전 버전의 세이브 파일이 호환되지 않는 문제가 발생한다. 따라서 저장 데이터 자체에 버전 정보를 포함하는 시스템을 구현해야 한다.

구현 방안:

실제 게임 데이터를 감싸는 최상위 래퍼(wrapper) 클래스를 정의한다.

저장 시: 현재 게임 데이터 객체를 MessagePack으로 직렬화하여 Payload에 담고, 현재 게임 버전을 Version에 기록한 후 SaveDataContainer 객체를 최종적으로 파일에 저장한다.

로드 시: 파일에서 SaveDataContainer를 먼저 역직렬화한다. 저장된 Version을 현재 게임 버전과 비교한다.

업그레이드 로직: 만약 저장된 버전이 낮다면, 해당 버전에서 현재 버전으로 데이터를 변환하는 '업그레이더(upgrader)' 함수를 단계적으로 실행한다. 예를 들어, Upgrade_V1_to_V2(), Upgrade_V2_to_V3()와 같은 함수들을 순차적으로 호출하여 데이터 구조를 최신화한 후, 최종적으로 게임에 적용한다. 이 방식은 장기적인 라이브 서비스에서 데이터 호환성을 유지하는 데 필수적이다.

Section 3.2: A Tiered Approach to Save Data Security
"Muscle & Blood"의 가챠 기반 용병 수집 시스템은 플레이어에게 희귀 용병이나 아이템을 획득하기 위해 세이브 파일을 조작하려는 강력한 동기를 부여한다. 이는 일반적인 싱글플레이 RPG보다 훨씬 높은 수준의 보안을 요구하는 이유가 된다. 클라이언트 측에서 완벽한 보안은 불가능하지만 , 여러 단계의 보안 계층을 적용하여 '캐주얼 해킹'을 방지하고 데이터 변조를 매우 어렵게 만들 수 있다.

Tier 1: Integrity Check (무결성 검증)
가장 기본적인 보안 단계는 데이터가 변조되었는지 여부를 확인하는 것이다.

방법: 저장될 데이터에 대한 **해시(Hash) 기반 메시지 인증 코드(HMAC)**를 생성하여 데이터와 함께 저장한다. 소금(salt)을 첨가한 SHA-256 해시 알고리즘이 강력하고 표준적인 선택이다.

프로세스:

저장: 직렬화된 데이터 save_data에 salt 값을 더한 후 해시 값을 계산한다: hash = SHA256(save_data + salt). 파일에는 save_data와 hash를 모두 저장한다.

로드: 파일에서 save_data와 hash를 읽어온다. 읽어온 save_data를 이용해 동일한 방식으로 해시를 다시 계산하고, 저장되어 있던 hash와 비교한다. 두 값이 다르면 파일이 변조된 것으로 간주하고 로드를 중단시킨다.

Tier 2: Obfuscation & Encryption (난독화 및 암호화)
무결성 검증만으로는 데이터의 내용을 숨길 수 없다. 헥스 에디터 등을 이용한 직접적인 수정을 막기 위해 암호화 계층이 필요하다.

방법: AES-256과 같은 강력하고 표준화된 대칭키 암호화 알고리즘을 사용하여 직렬화된 데이터 전체를 암호화한다.

핵심 문제: 키 관리(Key Management): 암호화의 강도는 키를 얼마나 안전하게 보관하느냐에 달려있다. 가장 흔한 실수는 암호화 키를 소스 코드에 하드코딩하는 것이다. 이는 디컴파일러를 통해 쉽게 추출될 수 있어 매우 취약하다. 단순한 XOR 연산 역시 쉽게 파훼된다.

초급 방어: 키를 여러 조각으로 나누어 코드나 애셋의 여러 부분에 분산시킨 후, 런타임에 이를 조합하여 사용하는 방식은 약간의 난독화 효과를 제공할 수 있다. 하지만 이것 역시 근본적인 해결책은 아니다.

Tier 3: Hardware-Secured Key Storage (하드웨어 기반 키 저장)
클라이언트 측에서 암호화 키를 가장 안전하게 보호하는 방법은 운영체제가 제공하는 하드웨어 보안 모듈을 활용하는 것이다. 이는 iOS의 Secure Enclave와 Android의 Android Keystore에 해당한다.

방법: 비대칭키 암호화 방식을 활용하여, 실제 데이터 암호화에 사용되는 대칭키(AES 키)를 하드웨어에서 생성 및 관리하는 비대칭키로 다시 암호화하여 저장한다.

프로세스:

최초 실행 시 키 생성: 게임이 처음 실행될 때, Secure Enclave 또는 Android Keystore에 비대칭키(개인키/공개키) 생성을 요청한다. 이 키 쌍 중 개인키는 절대로 보안 하드웨어 밖으로 노출되지 않는다.

데이터 저장 시:
a. 세이브 데이터를 암호화할 새로운 대칭키(예: AES-256 키)를 런타임에 생성한다.
b. 이 AES 키를 사용하여 실제 세이브 데이터(Payload)를 암호화한다.
c. 하드웨어에 저장된 공개키를 가져와, a에서 생성한 AES 키를 암호화한다.
d. 최종적으로 암호화된 세이브 데이터와 암호화된 AES 키를 파일에 저장한다.

데이터 로드 시:
a. 파일에서 암호화된 세이브 데이터와 암호화된 AES 키를 읽는다.
b. 암호화된 AES 키를 Secure Enclave/Android Keystore에 전달하고, 내장된 개인키로 복호화해달라고 요청한다.
c. 하드웨어로부터 복호화된 AES 키를 전달받는다.
d. 이 AES 키를 사용하여 암호화된 세이브 데이터를 복호화하여 원본 게임 데이터를 얻는다.

이 방식의 핵심은, 데이터 암호화의 '마스터 키' 역할을 하는 개인키가 애플리케이션 메모리에 전혀 노출되지 않는다는 점이다. 공격자가 앱을 리버스 엔지니어링하더라도 키를 탈취할 수 없으므로, 현재 클라이언트 측에서 구현할 수 있는 가장 높은 수준의 보안을 제공한다.

이러한 다계층 보안 아키텍처는 "Muscle & Blood"의 핵심 가치인 용병 수집과 성장의 재미를 외부 조작으로부터 보호하고, 게임의 공정성과 장기적인 경제 시스템의 안정을 유지하는 데 필수적인 투자이다.

Part IV: Forging a Legacy - Deepening the Meta-Game with Estate Management
"Muscle & Blood"의 프로젝트 개요에 명시된 "영지 경영"은 단순한 부가 기능을 넘어, 게임의 장기적인 깊이와 리플레이 가치를 결정하는 핵심 메타 게임(Meta-game)이 될 잠재력을 가지고 있다. 성공적인 영지 경영 시스템은 단발적인 전투의 재미를 지속적인 성장의 즐거움으로 연결하는 강력한 접착제 역할을 한다. 본 파트에서는 앞서 논의된 AI, ECS, 데이터 저장과 같은 기술적 기반 위에서 어떻게 매력적인 영지 경영 시스템을 구축하고, 이를 통해 플레이어의 몰입을 극대화할 수 있는지 분석한다.

Section 4.1: The Core Loop - Learning from the Masters (Darkest Dungeon & XCOM)
성공적인 영지 경영 시스템을 갖춘 게임들은 명확한 핵심 루프를 공유한다. 플레이어는 전술적 미션(전투)을 통해 자원을 획득하고, 이 자원을 전략적 거점(기지)에 투자하여 더 강력한 옵션을 해금한 뒤, 이를 활용해 더 어려운 미션에 도전한다. 이 루프의 대표적인 사례는 Darkest Dungeon의 '가주(Hamlet)' 시스템과 XCOM 시리즈의 '어벤저(Avenger)' 기지 관리 시스템이다.

Darkest Dungeon's Hamlet: A Blueprint for Resource and Personnel Management
Darkest Dungeon의 가주는 자원과 인력 관리의 교과서적인 예시를 보여준다. 플레이어는 던전 탐험을 통해 가보(초상화, 흉상, 증서, 문장)를 수집하고, 이를 사용하여 대장간, 길드, 요양원 등 각기 다른 기능을 가진 건물들을 업그레이드한다.

유기적 연결: 각 건물의 기능은 던전 탐험에 직접적인 영향을 미친다. 대장간은 장비를 강화하고, 길드는 스킬을 해금하며, 요양원은 영웅들의 스트레스와 부정적 기벽을 치료한다. 이는 "왜 던전을 탐험해야 하는가?"와 "획득한 자원을 어디에 투자해야 하는가?"에 대한 명확한 답을 제시한다.

전략적 선택: 제한된 가보를 어디에 우선적으로 투자할지는 플레이어의 핵심적인 전략적 고민이 된다. 당장 주력 영웅을 강화하기 위해 대장간에 투자할 것인가, 아니면 장기적으로 더 나은 영웅을 수급하기 위해 역마차를 업그레이드할 것인가의 선택은 게임의 깊이를 더한다.

XCOM's Avenger: A Tech Tree in Space
XCOM 2의 어벤저는 여기에 시설 건설 및 배치라는 공간적 요소를 추가하고, 자원 관리(보급품, 전력, 기술자)를 더욱 복잡하게 만든다.

연구와 제작: 게릴라 전술 학교는 분대 규모를 늘려주고, 연구실은 연구 속도를 가속하여 새로운 기술(예: 자기 무기, 플라즈마 무기)을 해금한다. 실험장은 이 기술들을 바탕으로 특수 탄환이나 수류탄 같은 강력한 소모성 아이템을 제작할 수 있게 해준다.

전술적 영향: 기지에서 내린 결정은 전술 전투에 직접적인 영향을 미친다. 예를 들어, '모방 비콘'을 연구하고 제작하는 데 성공하면, 전투에서 적의 어그로를 분산시켜 위기를 넘길 수 있는 강력한 전술적 도구를 얻게 된다. 이는 기지 관리와 전투가 분리된 것이 아니라 하나의 거대한 전략 루프임을 보여준다.

Recommendation for "Muscle & Blood"
"Muscle & Blood"의 영지(Estate) 시스템은 이 두 게임의 장점을 흡수하여, 단순한 메뉴 화면이 아닌 게임의 핵심 전략 레이어로 설계되어야 한다.

문제 해결 중심의 건물 설계: 영지의 각 건물은 플레이어가 던전에서 겪는 문제에 대한 해결책을 제공해야 한다.

대장간(Forge): 더 강력한 적을 상대하기 위한 상위 티어 장비 제작 및 [무게] 시스템과 연계된 경량화/중량화 개조 기능 제공.

훈련소(Training Ground): 용병의 스킬 슬롯 순서를 재조정하거나, 특정 스킬의 발동 확률을 높이는 훈련 제공. 이는 가챠로 획득한 용병의 무작위성을 플레이어가 통제할 수 있게 해주는 핵심 장치이다.

의무실(Infirmary): 전투에 참여하지 않은 용병들의 체력을 회복시키거나, 전투 중 얻은 부정적인 상태 이상을 치료하는 공간.

용병 길드(Mercenary Guild): 용병 고용, 해고, 그리고 용병 로스터의 최대 크기를 늘리는 기능을 담당한다.

Section 4.2: Designing the Estate's Economy & Progression
매력적인 영지 시스템은 잘 설계된 경제 및 성장 시스템을 기반으로 한다. 이는 자원 획득, 소비, 그리고 가챠 메커니즘과의 상호작용을 포함한다.

Resource Design and Economy
단일 화폐(골드) 시스템 대신, Darkest Dungeon의 가보처럼 여러 종류의 특수 자원을 도입하는 것이 효과적이다. 이는 플레이어에게 의미 있는 선택과 트레이드오프를 강제한다.

자원 분리: '고대 설계도'는 대장간 업그레이드에, '전장의 훈장'은 훈련소 업그레이드에 필요하도록 자원을 분리한다.

획득처 다변화: 특정 유형의 던전(예: 고블린 소굴, 언데드 묘지)에서 특정 자원의 드랍률을 높여, 플레이어가 다양한 던전을 탐험하도록 유도한다.

The Gacha-Economy Link
가챠 기반의 용병 수집은 영지 경제와 긴밀하게 연결되어야 한다. 이는 가챠의 부정적인 경험(꽝)을 완화하고, 시스템 전체의 깊이를 더하는 역할을 한다.

중복 용병 활용 (Duplicate Conversion): 가챠를 통해 이미 보유한 용병을 중복으로 획득했을 때, 이를 단순히 버리는 것이 아니라 의미 있는 자원으로 전환하는 시스템을 도입해야 한다.

자원 변환: 중복 용병을 '해고'하면 소량의 '전장의 훈장'이나 골드를 얻게 한다.

일시적 부스트: 특정 등급 이상의 중복 용병은 영지 건물에 '파견'하여 일정 기간 동안 해당 건물의 효율(예: 업그레이드 비용 할인, 훈련 시간 단축)을 높이는 부스터로 활용할 수 있다.

Applying Prospect Theory to Resource Design
경제 시스템 설계에는 심리학적 원리, 특히 **전망 이론(Prospect Theory)**과 **손실 회피(Loss Aversion)**를 적용하여 플레이어의 경험을 최적화할 수 있다. 전망 이론에 따르면, 사람들은 동일한 가치의 이득에서 얻는 기쁨보다 손실에서 느끼는 고통을 약 2배 더 크게 느낀다.

손실 프레이밍 최소화: 업그레이드 실패와 같은 직접적인 자원 손실은 플레이어에게 큰 스트레스를 준다. 대신, '위험한 투자'와 같은 프레임을 사용할 수 있다. 예를 들어, "불안정한 마법 부여"는 낮은 비용으로 큰 성공을 거둘 수도 있지만, 낮은 확률로 장비에 페널티가 붙을 수도 있는 식이다.

이득 분리 (Segregate Gains): 하나의 큰 보상보다는 여러 개의 작은 보상을 나누어 제공하는 것이 플레이어의 만족도를 더 높인다. 예를 들어, 건물 업그레이드 시 "비용 10% 감소"라는 단일 효과 대신, "비용 5% 감소, 훈련 성공률 3% 증가, 새로운 훈련 슬롯 1개 해금"과 같이 여러 작은 긍정적 효과를 묶어서 제공하는 것이 더 효과적이다.

이러한 메타 게임 설계는 "Muscle & Blood"를 단순한 전투 게임의 반복에서 벗어나, 플레이어가 자신만의 군대와 영지를 키워나가는 장대한 캠페인으로 변화시킨다. 가챠를 통해 잠재력(용병)을 획득하고, 던전 탐험을 통해 자원(가보)을 모으며, 영지에서 투자를 통해 잠재력을 실제적인 힘으로 변환하는 이 세 단계의 핵심 루프(획득 -> 수집 -> 투자)는 플레이어에게 강력하고 지속적인 동기를 부여하며, 게임의 장기적인 성공을 이끄는 핵심 엔진이 될 것이다.

Proposed Table 3: Estate Building & Upgrade Tree
다음 표는 영지 경영 시스템의 전체적인 설계도를 보여주는 고수준 디자인 문서의 예시이다. 이를 통해 게임의 장기 경제와 성장 경로의 균형을 맞추고 구현 계획을 수립할 수 있다.

Conclusions and Recommendations
본 보고서는 "Muscle & Blood" 프로젝트가 가진 견고한 기반과 높은 잠재력을 인식하고, 이를 한 단계 더 발전시키기 위한 구체적이고 실행 가능한 전략적 로드맵을 제시하였다. 분석된 네 가지 핵심 영역—AI, 아키텍처, 데이터 영속성, 메타 게임—은 서로 독립된 과제가 아니라, 게임의 총체적인 경험을 구성하는 상호 연결된 요소들이다.

최종 권장 사항은 다음과 같이 요약할 수 있다.

AI는 '똑똑한 상대'를 넘어 '흥미로운 교사'가 되어야 한다: [용맹]과 [무게] 시스템의 깊이를 플레이어에게 효과적으로 전달하기 위해, 행동 트리와 유틸리티 시스템의 하이브리드 아키텍처를 도입해야 한다. 이는 디자이너가 의도한 전술적 경험을 유지하면서도, AI가 상황에 맞는 유연하고 합리적인 판단을 내리게 하여 전투의 질을 높일 것이다.

아키텍처는 '현재의 효율성'과 '미래의 확장성'을 모두 고려해야 한다: 성능이 중요한 전투 관련 시스템은 Unity DOTS를 활용한 ECS로 점진적으로 전환하고, UI와 같은 다른 시스템은 기존의 안정적인 GameObject 방식을 유지하는 하이브리드 ECS 전략이 가장 실용적이다. 이는 개발 리스크를 최소화하면서 성능상의 이점을 극대화하는 최적의 경로이다.

데이터 저장은 '편의성'과 '보안성'의 균형을 맞춰야 한다: 가챠 시스템의 존재는 세이브 데이터 보안의 중요성을 극적으로 높인다. MessagePack을 통한 고속 바이너리 직렬화를 기본으로 하되, **다계층 보안 모델(체크섬, AES-256 암호화, 모바일 하드웨어 키 저장소 활용)**을 반드시 적용하여 게임의 핵심 자산 가치와 경제 시스템의 무결성을 지켜야 한다.

메타 게임은 '지속 가능한 재미'의 원천이 되어야 한다: "영지 경영" 시스템을 전투-자원-성장으로 이어지는 강력한 핵심 루프로 설계해야 한다. Darkest Dungeon과 XCOM의 사례에서 보듯, 기지 관리는 단순한 업그레이드 메뉴가 아니라, 플레이어에게 장기적인 목표와 전략적 선택의 즐거움을 제공하는 게임의 심장부 역할을 해야 한다.

"Muscle & Blood"는 이미 성공적인 게임이 될 수 있는 독창적이고 매력적인 핵심 요소들을 갖추고 있다. 본 보고서에서 제안된 기술적, 설계적 발전 방향을 체계적으로 이행한다면, 이 잠재력은 현실이 되어 플레이어들에게 오랫동안 기억에 남는 깊이 있는 전략 RPG 경험을 선사할 수 있을 것으로 확신한다.
